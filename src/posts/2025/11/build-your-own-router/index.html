---
title: "Build Your Own Router"
excerpt: "Wake up, honey, URLPattern just dropped.  It's time to make our own SPA router with web components!"
layout: post
tags:
  - posts
  - routing
  - spa
  - using the platform
  - vanilla JavaScript
  - web components
date: 2025-11-11
image: leaves.webp
---

<h1>Build Your Own Router</h1>

<p class="post-details">Published {% prettyDate date %}, {% readTime page %}</p>

<p><code>URLPattern</code> just became available in all browsers:</p>

<baseline-status featureId="urlpattern"></baseline-status>

<p>
  So I wanted to dig into what it would take to make a simple SPA router with
  vanilla JavaScript and browser APIs. We should be able to make a component
  that takes in a router configuration and renders the appropriate component
  determined by the browser URL.
</p>

<h2>What does <code>URLPattern()</code> Do?</h2>

<p>
  Conditionally rendering components is not the difficult part with routers. The
  difficult part is accurately testing the browser URL to determine which
  component should render. And not only that, we have to be able to capture
  dynamic parts of routes (think something like <code>/posts/{post_id}</code>.)
</p>

<p>
  So, without further ado, here are some examples showing how to test if a route
  URL matches a pattern! You can then use this mechanism to create a router with
  easily configured paths.
</p>

<code-highlight lang="javascript">
  <template>
    <script>
      const catUrlPattern = new URLPattern({ pathname: "/cat" });

      catUrlPattern.test("http://www.jschof.dev/cat"); // True!

      catUrlPattern.test("http://www.jschof.dev/dog"); // False!

      catUrlPattern.test({ pathname: "/cat" }); // True!

      catUrlPattern.test("http://www.jschof.dev/cat/"); // False!

      catUrlPattern.test("http://www.jschof.dev/cat/other-things?yes"); // False!
    </script>
  </template>
</code-highlight>

<p>
  You might be surprised by the fourth example above. There is a distinction
  between <code>/cat</code> and <code>/cat/</code>. So to handle this, you can
  make the pattern optionally include an ending forward slash in a group with
  curly brackets and mark it optional with <code>?</code>:
</p>

<code-highlight lang="javascript">
  <template>
    <script>
      const catUrlPattern = new URLPattern({ pathname: "/cat{/}?" });

      catUrlPattern.test("http://www.jschof.dev/cat"); // True!

      catUrlPattern.test({ pathname: "/cat/" }); // True!

      catUrlPattern.test("http://www.jschof.dev/cat/"); // True!

      catUrlPattern.test("http://www.jschof.dev/cat/other-things?yes"); // False!
    </script>
  </template>
</code-highlight>

<p>
  Yet another surprise! You may expect that you can accept more after
  <code>/cat/</code>. To do that, include a wildcard asterisk:
</p>

<code-highlight lang="javascript">
  <template>
    <script>
      const catUrlPattern = new URLPattern({ pathname: "/cat{/}?*" });

      catUrlPattern.test("http://www.jschof.dev/cat"); // True!

      catUrlPattern.test({ pathname: "/cat/" }); // True!

      catUrlPattern.test("http://www.jschof.dev/cat/"); // True!

      catUrlPattern.test("http://www.jschof.dev/cat/other-things?yes"); // True!
    </script>
  </template>
</code-highlight>

<h2>Where do we start?</h2>

<p>
  I'm going to use an array of config objects that tie a URL route to specific
  web components. It's very similar to how you can create routers with
  <a href="https://router.vuejs.org/guide/#Creating-the-router-instance"
    >vue-router</a
  >.
</p>

<code-highlight lang="javascript">
  <template>
    <script>
      const routerConfig = [
        { pathName: new URLPattern("/home{/}?"), component: "my-home" },
        { pathName: new URLPattern("/posts{/}?"), component: "my-posts" },
        { pathName: new URLPattern("/about{/}?"), component: "my-about" },
      ];
    </script>
  </template>
</code-highlight>

<p>
  The order of the config objects matters. We'll be testing each pattern one by
  one, and if we find a match, we'll render that web component.
</p>

<code-highlight lang="javascript">
  <template>
    <script>
      for (const config of routerConfig) {
        if (config.pathName.test(window.location.href)) {
          // render config.component!

          return;
        }
      }

      // TODO: Handle 404!
    </script>
  </template>
</code-highlight>

<p>
  How do we do the rendering? That would be the job of the web component we're
  placing all this logic in. The component will look at the current window URL,
  test that against all the router configs that we set up with URLPattern, and
  create and render the appropriate web component as a child.
</p>

<p>Some frameworks call this router the "outlet" component.</p>

<code-highlight lang="javascript">
  <template>
    <script>
      const routerConfig = [
        { pathName: new URLPattern("/home{/}?"), component: "my-home" },
        { pathName: new URLPattern("/posts{/}?"), component: "my-posts" },
        { pathName: new URLPattern("/about{/}?"), component: "my-about" },
      ];

      class MyRouter extends HTMLElement {
        constructor() {
          super();

          const matchedComponent = this.getRouteMatch();
          this.renderComponent(matchedComponent);
        }

        getRouteMatch() {
          for (const config of routerConfig) {
            if (config.pathName.test(window.location.href)) {
              return config.component;
            }
          }

          // TODO: handle 404!
        }

        renderComponent(component) {
          this.innerHTML = "";

          const viewElement = document.createElement(component);

          this.appendChild(viewElement);
        }
      }

      customElements.define("my-router", MyRouter);
    </script>
  </template>
</code-highlight>

<p>
  Of course, you will need to have the web components <code>my-home</code>,
  <code>my-posts</code>, and <code>my-about</code> registered as well.
</p>

<p>
  But there we have it - a router that will render the appropriate web component
  on page load. We have much work to do, though. What if someone clicks a link?
  What if someone uses the browser to navigate forward or backward? We need to
  handle those, and luckily it's not too difficult.
</p>

<h2>Handling SPA Navigation and Link Clicks</h2>

<p>
  One thing to realize is that if you navigate to
  <code>http://www.myblog.com/some/path</code> the server is going to normally
  try to resolve <code>/some/path</code> on the back end. It might actually look
  for the folders "some" and "path". But in a SPA we don't have folders- we have
  one index HTML file that handles <em>virtual</em> paths. It's all done in the
  client in JS! No matter which path we're going to, the server really only has
  to serve up the index page. The client will then take over, use our new
  <code>URLPattern</code> and handle rendering the appropriate component.
</p>

<p>
  For configuring Vite to do this, it's dead simple. You can use a configuration
  called <code>spa</code>. Just update your vite config:
</p>

<code-highlight lang="javascript">
  <template>
    <script>
      import { defineConfig } from "vite";

      export default defineConfig({
        appType: "spa",
      });
    </script>
  </template>
</code-highlight>

<p>
  This works well for your Vite local server. Unfortunately it's going to depend
  on where you deploy and what other frameworks/dev servers you're using. For
  some places like netlify you'll need to set a redirect rule in your netlify
  config. You may have to consult Stack Overflow, Google, or your LLM of choice
  to figure out how to do this for your particular situation.
</p>

<p>
  But once you've got your server configuration and redirects in place, we can
  then start handling clicks!
</p>

<p>
  We want to basically coopt any link clicks, and stop the browser from
  navigating normally. This means we <code>preventDefault()</code> all click
  events, and pull the target of the link out to test against our URL patterns.
  This lets us know which component to render, and we set the URL manually to be
  what the anchor tag was pointing to. It looks like we're changing pages, but
  really we're simulating a page transition.
</p>

<p>
  We need to set up a click handler when our router component connects to the
  DOM:
</p>

<code-highlight lang="javascript">
  <template>
    <script>
      class MyRouter extends HTMLElement {
        //...

        connectedCallback() {
          window.addEventListener("click", this.handleClicks);
        }

        handleClicks = (event) => {
          if (event.target instanceof HTMLAnchorElement) {
            // Don't handle this link like usual!
            event.preventDefault();

            // Set the URL manually
            const toUrl = event.target.getAttribute("href");
            window.history.pushState({}, "", toUrl);

            // Now that the URL is set, do the usual matching
            // and rendering!
            const matchedComponent = this.getRouteMatch();
            this.renderComponent(matchedComponent);
          }
        };

        disconnectedCallback() {
          window.removeEventListener("click", this.handleClicks);
        }
      }
    </script>
  </template>
</code-highlight>

<p>
  Of course, make sure you tear down these handlers in the
  <code>disconnectedCallback</code>!
</p>

<p>
  The user sees the URL change, the page transition, and even a new entry in the
  browser navigation history when a user clicks on a link. Now, we need to make
  sure that the browser doesn't actually go back or forward, but hooks into our
  router when back or forward buttons are clicked.
</p>

<aside class="blue">
  <p>
    In the above example we co-opt every click on an anchor tag, whether the
    click is in our router component or not. You might want to just handle
    clicks only inside this router component so that you aren't assuming
    responsibility of links on the whole page.
  </p>
  <p>
    Also, be aware that we haven't even touched how we're going to handle
    external links. That requires special care, but that's beyond the scope of
    this blog post.
  </p>
</aside>

<h2>One last detail: browser navigation</h2>

<p>
  When a browser goes back or forward either programmatically (with
  <code>window.back()/forward()</code>) or from a user clicking the back/forward
  buttons, an event gets emitted: <code>popstate</code>.
</p>

<p>
  The nice thing about this event is that the browser already moves back/forward
  to the entry that we've been pushing to the history stack when we used
  <code>window.pushState</code>. In other words, we just have to listen when
  this back/forward navigation happens, and render our component. After
  back/forward is pressed, the URL is already updated
</p>

<p>So here is the final piece for our minimal viable router:</p>

<code-highlight lang="javascript">
  <template>
    <script>
      class MyRouter extends HTMLElement {
        //...

        connectedCallback() {
          window.addEventListener("click", this.handleClicks);
          window.addEventListener("popstate", this.handlePopState);
        }

        handlePopState = (event) => {
          const matchedComponent = this.getRouteMatch();
          this.renderComponent(matchedComponent);
        };

        disconnectedCallback() {
          window.removeEventListener("click", this.handleClicks);
          window.removeEventListener("popstate", this.handlePopState);
        }
      }
    </script>
  </template>
</code-highlight>

<h2>A working example</h2>

<p>
  If you're interested in seeing it work, here's an example built out in
  StackBlitz.
</p>

<embed
  src="https://stackblitz.com/edit/vitejs-vite-vf79hwkk?embed=1&file=src%2Frouter%2Frouter.ts"
/>

<p>
  There's more to do! Here is the list of things I would suggest investigating:
</p>

<ul>
  <li>
    Creating dynamic segments like <code>/posts/:id</code>.
    <a
      href="https://developer.mozilla.org/en-US/docs/Web/API/URL_Pattern_API#fixed_text_and_capture_groups"
      >Here's some docs on handling dynamic parameters</a
    >
  </li>
  <li>Handling query parameters with <code>search</code>.</li>
  <li>Handling nested or sub-routers</li>
</ul>

<h3>Things to keep in mind...</h3>

<p>
  We are working pretty low-level. Making your own router renderer like this can
  expose you to XSS if you leave open ways for people to mess with your router
  config. For example, if you let people set the configuration array directly on
  the router component, someone could come along and register their own web
  component in the console, and navigate to their component to render it.
  Effectively, you would be allowing other parties to run their code in your
  router!
</p>

<p>
  This is why, at least in the example being discussed here, the router
  configuration is defined in a private variable in our router component. If we
  exposed this property publicly, someone could register their own web component
  and have our router render it.
</p>

<p>
  How do we solve this? I would say
  <strong
    >never render based purely off the query params or dynamic segments of a
    URL</strong
  >. Always keep the actual rendering web components in a static list- probably
  a list that's in a private variable on the router.
</p>

<p>
  Another thing- should we be building a router with web components? Eh... maybe
  not? Lit seems to think
  <a href="https://www.npmjs.com/package/@lit-labs/router"
    >it would be helpful and useful</a
  >. But there are a lot of considerations you have to handle with your own
  implementation that framework routers have already solved. Web components also
  add another level of security you need to be aware of.
</p>

<p>
  I think it's worth investigating and learning from. And it's also nice to
  understand the native APIs that continue to come out and make our lives easier
  as we lean into the platform.
</p>

<p>Until next time.</p>

<p>{%socials%}</p>
